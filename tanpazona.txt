package main





import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	_ "github.com/lib/pq"
)

// Structs
type SensorData struct {
	ID              int     `json:"id"`
	DeviceUniqueID  string  `json:"device_unique_id"`
	ParameterName   string  `json:"parameter_name"`
	Value           float64 `json:"value,string"`
	RecordedAt      string  `json:"recorded_at"`
}

type AggregatedData struct {
	DeviceUniqueID string  `json:"device_unique_id"`
	ParameterName  string  `json:"parameter_name"`
	Value          float64 `json:"value"`
	Mode           string  `json:"mode"`
	FromTime       string  `json:"from_time"`
	ToTime         string  `json:"to_time"`
}

type Response struct {
	Status   bool        `json:"status"`
	Filter   string      `json:"filter"`
	Mode     string      `json:"mode"`
	Timezone string      `json:"timezone,omitempty"`
	DeviceID string      `json:"device_id,omitempty"`
	Month    string      `json:"month,omitempty"`
	Year     string      `json:"year,omitempty"`
	TimeRange string     `json:"time_range,omitempty"`
	Total    int         `json:"total"`
	Data     interface{} `json:"data"`
	Message  string      `json:"message,omitempty"`
}

var db *sql.DB

// Database connection
func initDB() {
	connStr := "host=localhost port=5432 user=postgres password=example dbname=temins sslmode=disable"
	var err error
	db, err = sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	// Connection pool settings
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)
	db.SetConnMaxLifetime(5 * time.Minute)

	if err = db.Ping(); err != nil {
		log.Fatal("Failed to ping database:", err)
	}
	
	log.Println("âœ… Database connected successfully")
}

// Parse month parameter
func parseMonth(bulan string) (month, year string) {
	parts := strings.Split(bulan, "-")
	
	switch len(parts) {
	case 3: // MM-DD-YYYY
		return parts[0], parts[2]
	case 2: // MM-YYYY
		return parts[0], parts[1]
	default: // MM only
		return bulan, strconv.Itoa(time.Now().Year())
	}
}

// Main handler
func getSensorData(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

	if r.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	// Parse parameters
	q := r.URL.Query()
	deviceID := q.Get("device_id")
	jenis := q.Get("jenis")
	periode := q.Get("periode")
	if periode == "" {
		periode = "hari"
	}
	mode := q.Get("mode")
	if mode == "" {
		mode = "raw"
	}
	tahun := q.Get("tahun")
	if tahun == "" {
		tahun = strconv.Itoa(time.Now().Year())
	}
	bulan := q.Get("bulan")
	tanggal := q.Get("tanggal")
	valueMode := q.Get("value")

	// Validate device_id
	if deviceID == "" {
		respondError(w, "device_id wajib diisi", http.StatusBadRequest)
		return
	}

	tzQuery := "recorded_at AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Jakarta'"

	// MODE: ALL PARAMETERS
	if jenis == "" && valueMode == "" && periode == "hari" {
		if bulan != "" {
			handleAllParametersByMonth(w, deviceID, bulan, tzQuery)
		} else {
			handleAllParameters(w, deviceID, tzQuery)
		}
		return
	}

	// MODE: NOW (Latest data)
	if periode == "now" {
		handleNowMode(w, deviceID, tzQuery)
		return
	}

	// MODE: VALUE (high/low/avg)
	if valueMode != "" {
		if jenis == "" {
			respondError(w, "parameter jenis diperlukan untuk mode value", http.StatusBadRequest)
			return
		}
		handleValueMode(w, deviceID, jenis, valueMode, tanggal, tzQuery)
		return
	}

	// MODE: PERIODE
	if jenis == "" {
		respondError(w, "parameter jenis diperlukan", http.StatusBadRequest)
		return
	}

	if tanggal != "" {
		handlePeriodeByDate(w, deviceID, jenis, tanggal, mode, tzQuery)
		return
	}

	handlePeriode(w, deviceID, jenis, periode, mode, tahun, bulan, tzQuery)
}

// Handler: All parameters (24 hours)
func handleAllParameters(w http.ResponseWriter, deviceID, tzQuery string) {
	query := fmt.Sprintf(`
		SELECT id, device_unique_id, parameter_name, value, 
		       (%s) AS recorded_at
		FROM sensor_logs
		WHERE device_unique_id = $1
		  AND recorded_at >= NOW() - INTERVAL '24 HOURS'
		ORDER BY recorded_at DESC
		LIMIT 20000
	`, tzQuery)

	rows, err := db.Query(query, deviceID)
	if err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	data := []SensorData{}
	for rows.Next() {
		var s SensorData
		if err := rows.Scan(&s.ID, &s.DeviceUniqueID, &s.ParameterName, &s.Value, &s.RecordedAt); err != nil {
			continue
		}
		data = append(data, s)
	}

	respond(w, Response{
		Status:    true,
		Filter:    "all_parameters",
		Mode:      "raw",
		Timezone:  "Asia/Jakarta",
		DeviceID:  deviceID,
		TimeRange: "24_hours",
		Total:     len(data),
		Data:      data,
	})
}

// Handler: All parameters by month
func handleAllParametersByMonth(w http.ResponseWriter, deviceID, bulan, tzQuery string) {
	month, year := parseMonth(bulan)
	
	query := fmt.Sprintf(`
		SELECT id, device_unique_id, parameter_name, value, 
		       (%s) AS recorded_at
		FROM sensor_logs
		WHERE device_unique_id = $1
		  AND EXTRACT(YEAR FROM recorded_at) = $2
		  AND EXTRACT(MONTH FROM recorded_at) = $3
		ORDER BY recorded_at DESC, parameter_name ASC
		
	`, tzQuery)

	rows, err := db.Query(query, deviceID, year, month)
	if err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	data := []SensorData{}
	for rows.Next() {
		var s SensorData
		if err := rows.Scan(&s.ID, &s.DeviceUniqueID, &s.ParameterName, &s.Value, &s.RecordedAt); err != nil {
			continue
		}
		data = append(data, s)
	}

	respond(w, Response{
		Status:   true,
		Filter:   "all_parameters_by_month",
		Mode:     "raw",
		Timezone: "Asia/Jakarta",
		DeviceID: deviceID,
		Month:    month,
		Year:     year,
		Total:    len(data),
		Data:     data,
	})
}

// Handler: NOW mode
func handleNowMode(w http.ResponseWriter, deviceID, tzQuery string) {
	query := fmt.Sprintf(`
		SELECT DISTINCT ON (parameter_name)
		       id, device_unique_id, parameter_name, value,
		       (%s) AS recorded_at
		FROM sensor_logs
		WHERE device_unique_id = $1
		ORDER BY parameter_name ASC, recorded_at DESC
	`, tzQuery)

	rows, err := db.Query(query, deviceID)
	if err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	data := []SensorData{}
	for rows.Next() {
		var s SensorData
		if err := rows.Scan(&s.ID, &s.DeviceUniqueID, &s.ParameterName, &s.Value, &s.RecordedAt); err != nil {
			continue
		}
		data = append(data, s)
	}

	respond(w, Response{
		Status: true,
		Filter: "now",
		Mode:   "latest",
		Total:  len(data),
		Data:   data,
	})
}

// Handler: VALUE mode
func handleValueMode(w http.ResponseWriter, deviceID, jenis, valueMode, tanggal, tzQuery string) {
	var agg string
	switch valueMode {
	case "high":
		agg = "MAX(value)"
	case "low":
		agg = "MIN(value)"
	case "avg":
		agg = "AVG(value)"
	default:
		respondError(w, "value hanya high | low | avg", http.StatusBadRequest)
		return
	}

	var whereTime string
	var args []interface{}
	if tanggal != "" {
		whereTime = "AND recorded_at >= $3::date AND recorded_at < ($3::date + INTERVAL '1 day')"
		args = []interface{}{deviceID, jenis, tanggal}
	} else {
		whereTime = "AND recorded_at >= NOW() - INTERVAL '24 HOURS'"
		args = []interface{}{deviceID, jenis}
	}

	query := fmt.Sprintf(`
		SELECT device_unique_id, parameter_name,
		       ROUND((%s)::numeric, 2) AS value,
		       '%s' AS mode,
		       MIN(%s) AS from_time,
		       MAX(%s) AS to_time
		FROM sensor_logs
		WHERE device_unique_id = $1
		  AND parameter_name = $2
		  %s
		GROUP BY device_unique_id, parameter_name
	`, agg, valueMode, tzQuery, tzQuery, whereTime)

	var result AggregatedData
	err := db.QueryRow(query, args...).Scan(
		&result.DeviceUniqueID,
		&result.ParameterName,
		&result.Value,
		&result.Mode,
		&result.FromTime,
		&result.ToTime,
	)

	if err == sql.ErrNoRows {
		respond(w, Response{
			Status: true,
			Filter: valueMode,
			Mode:   valueMode,
			Total:  0,
			Data:   []interface{}{},
		})
		return
	}

	if err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}

	respond(w, Response{
		Status:   true,
		Filter:   valueMode,
		Mode:     valueMode,
		Timezone: "Asia/Jakarta",
		Total:    1,
		Data:     []AggregatedData{result},
	})
}

// Handler: Periode by date
func handlePeriodeByDate(w http.ResponseWriter, deviceID, jenis, tanggal, mode, tzQuery string) {
	var query string

	if mode == "ringkas" {
		query = fmt.Sprintf(`
			SELECT MIN(id) AS id, device_unique_id, parameter_name,
			       ROUND(AVG(value)::numeric, 2) AS value,
			       DATE_TRUNC('hour', %s) AS recorded_at
			FROM sensor_logs
			WHERE device_unique_id = $1
			  AND parameter_name = $2
			  AND recorded_at >= $3::date
			  AND recorded_at < ($3::date + INTERVAL '1 day')
			GROUP BY device_unique_id, parameter_name, DATE_TRUNC('hour', %s)
			ORDER BY recorded_at ASC
		`, tzQuery, tzQuery)
	} else {
		query = fmt.Sprintf(`
			SELECT id, device_unique_id, parameter_name, value,
			       (%s) AS recorded_at
			FROM sensor_logs
			WHERE device_unique_id = $1
			  AND parameter_name = $2
			  AND recorded_at >= $3::date
			  AND recorded_at < ($3::date + INTERVAL '1 day')
			ORDER BY recorded_at ASC
		`, tzQuery)
	}

	rows, err := db.Query(query, deviceID, jenis, tanggal)
	if err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	data := []SensorData{}
	for rows.Next() {
		var s SensorData
		if err := rows.Scan(&s.ID, &s.DeviceUniqueID, &s.ParameterName, &s.Value, &s.RecordedAt); err != nil {
			continue
		}
		data = append(data, s)
	}

	respond(w, Response{
		Status:   true,
		Filter:   "tanggal",
		Mode:     mode,
		Timezone: "Asia/Jakarta",
		Total:    len(data),
		Data:     data,
	})
}

// Handler: Periode
func handlePeriode(w http.ResponseWriter, deviceID, jenis, periode, mode, tahun, bulan, tzQuery string) {
	var query string
	var args []interface{}

	switch periode {
	case "hari":
		if mode == "ringkas" {
			query = fmt.Sprintf(`
				SELECT MIN(id) AS id, device_unique_id, parameter_name,
				       ROUND(AVG(value)::numeric, 2) AS value,
				       DATE_TRUNC('hour', %s) AS recorded_at
				FROM sensor_logs
				WHERE device_unique_id = $1
				  AND parameter_name = $2
				  AND recorded_at >= NOW() - INTERVAL '24 HOURS'
				GROUP BY device_unique_id, parameter_name, DATE_TRUNC('hour', %s)
				ORDER BY recorded_at ASC
			`, tzQuery, tzQuery)
		} else {
			query = fmt.Sprintf(`
				SELECT id, device_unique_id, parameter_name, value,
				       (%s) AS recorded_at
				FROM sensor_logs
				WHERE device_unique_id = $1
				  AND parameter_name = $2
				  AND recorded_at >= NOW() - INTERVAL '24 HOURS'
				ORDER BY recorded_at ASC
			`, tzQuery)
		}
		args = []interface{}{deviceID, jenis}

	case "minggu_ini":
		if mode == "ringkas" {
			query = fmt.Sprintf(`
				SELECT MIN(id) AS id, device_unique_id, parameter_name,
				       ROUND(AVG(value)::numeric, 2) AS value,
				       DATE(%s) AS recorded_at
				FROM sensor_logs
				WHERE device_unique_id = $1
				  AND parameter_name = $2
				  AND recorded_at >= CURRENT_DATE - INTERVAL '6 DAYS'
				GROUP BY device_unique_id, parameter_name, DATE(%s)
				ORDER BY recorded_at ASC
			`, tzQuery, tzQuery)
		} else {
			query = fmt.Sprintf(`
				SELECT id, device_unique_id, parameter_name, value,
				       (%s) AS recorded_at
				FROM sensor_logs
				WHERE device_unique_id = $1
				  AND parameter_name = $2
				  AND recorded_at >= NOW() - INTERVAL '7 DAYS'
				ORDER BY recorded_at ASC
			`, tzQuery)
		}
		args = []interface{}{deviceID, jenis}

	case "bulan":
		if bulan != "" {
			month, year := parseMonth(bulan)
			tahun = year
			bulan = month
		} else if bulan == "" {
			bulan = fmt.Sprintf("%02d", time.Now().Month())
		}

		if mode == "ringkas" {
			query = fmt.Sprintf(`
				SELECT MIN(id) AS id, device_unique_id, parameter_name,
				       ROUND(AVG(value)::numeric, 2) AS value,
				       DATE(%s) AS recorded_at
				FROM sensor_logs
				WHERE device_unique_id = $1
				  AND parameter_name = $2
				  AND EXTRACT(YEAR FROM recorded_at) = $3
				  AND EXTRACT(MONTH FROM recorded_at) = $4
				GROUP BY device_unique_id, parameter_name, DATE(%s)
				ORDER BY recorded_at ASC
			`, tzQuery, tzQuery)
		} else {
			query = fmt.Sprintf(`
				SELECT id, device_unique_id, parameter_name, value,
				       (%s) AS recorded_at
				FROM sensor_logs
				WHERE device_unique_id = $1
				  AND parameter_name = $2
				  AND EXTRACT(YEAR FROM recorded_at) = $3
				  AND EXTRACT(MONTH FROM recorded_at) = $4
				ORDER BY recorded_at ASC
			`, tzQuery)
		}
		args = []interface{}{deviceID, jenis, tahun, bulan}

	default:
		respondError(w, "Periode tidak valid", http.StatusBadRequest)
		return
	}

	rows, err := db.Query(query, args...)
	if err != nil {
		respondError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	data := []SensorData{}
	for rows.Next() {
		var s SensorData
		if err := rows.Scan(&s.ID, &s.DeviceUniqueID, &s.ParameterName, &s.Value, &s.RecordedAt); err != nil {
			continue
		}
		data = append(data, s)
	}

	respond(w, Response{
		Status:   true,
		Filter:   periode,
		Mode:     mode,
		Timezone: "Asia/Jakarta",
		Total:    len(data),
		Data:     data,
	})
}

// Helper: Respond with JSON
func respond(w http.ResponseWriter, data Response) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(data)
}

// Helper: Respond with error
func respondError(w http.ResponseWriter, message string, code int) {
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(Response{
		Status:  false,
		Message: message,
	})
}

func main() {
	initDB()
	defer db.Close()
	http.HandleFunc("/api/export/excel-multi", exportExcelMultiSensor)

	http.HandleFunc("/api/get-data", getSensorData)

	port := ":8080"
	log.Printf("ðŸš€ Server running on http://localhost%s", port)
	log.Fatal(http.ListenAndServe(port, nil))
}